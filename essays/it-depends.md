---
layout: essay
type: essay
title: "It Depends"
# All dates must be YYYY-MM-DD format!
date: 2024-01-17
published: true
labels:
  - Software Engineering
  - Programming Languages
---

<img width="100px" class="rounded float-start pe-4" src="../img/igniting/paintbrushes.jpg">

## Hailing From Industry

Javascript, from what I've been enculturated, was foreseen to be the programming language of the future. Or that is what my mentors claimed back then. I'm not necessarily new when it comes to javascript, in fact, I believe my first exposure to this programming language was 8 years ago! Looking back to my github account, my first commit was a DistanceFormula algorithm, written in Javascript back in 2016. It generated random plot points (x1, y1) and (x2, y2) which then computes the distance between such points. I was quite a geeky kid back then, so computers was my niche in high school, as to, say, the jocks and sports, or nerds and maths. I was obsess with computers, then led astray to the whole scene of comptuer sciences, algorithms, programming, and of course - Silicon Valley when I was young.

Now, hailing from industry, my mental models now reign down to adapting to the newest and brightest frameworks of 2024 and beyond. So, learning pure javascript is quite a nostlogic for me, going from the very basics of declaring variables, initializing function signatures, and how to implement the common programming constructs like sequences, selections, and loops. Although, I've been exposed to these concepts a long time ago, I enjoy re-learning the naunces of Javascript, or any programming languages, really. It shows you how the authors of such languages envision of how programs should be design and constructed, and of course - going from the very archaic languages like LISP, FORTAN, BASIC, etc. and how such authors designed their language based their problems of such times. This usually entails techniques or practices that are long dead or declared bad practices in modern times. This, also entails, Javascript. A language that was once claimed to be *the programming language* of the future.

## Typescript > Javascript

### It Depends
Now, I've been exposed to industry CS, and I would say that most software engineers, when building complex and large scale software with hudnreds or thousands of engineers like you and me, would often pick a programming language that is naturally aligned to the task in hand. Typescript, from what my mentors taught me, enables developer's producitivity to blossom as the software system grows larger and larger. Now, going from Javascript to Typescript is a strong entry of barrier, and from my personal experiences, I would get a headache attemping to get the code getting to work, due to its strong emphasis in its typing rules.  But from my experiences, the strong learning curve is the cost of building a scalable and maintainable software system down the line. Though, that is not to say that one must adopt Typescript for every javascript project, but do a very research of the nature of the project itself, and if Typescript can be much of a better solution than Javascript, and usually the characteristics of industry aligns with the characterisics of Typescript.

Even with ES6, the lack of static typing is not ideal in industyr. Stability is one of the characteristics that software engineers should strive when building large scale applications, and dynamic typing is not ideal for such vision. When re-learning javascript, I cringed to the idea of not declaring types to my variables, function signatures, and return values. From my experiences, I can see how the accumulation of such code leads to inaccuracies and security vulnerabilities.

Another thing I love about Typescript, or say, what I dislike about Javascript is its error feedback system. Naturally, your javascript is determined at runtime, that is, you wait and see if there exist an error whilst the system is actively running. This is not necessarily quite a ideal design to have if your software is running to hundreds or millions of users One of my key characteristics when programming is to have a system in place where it provides real time error feedback of the code you're writing. I love it when my compiler is enganging with my code in real time, even moreso, if with a lint system in place when writing and correcting code in real time. Javascript doens't tap into my flow when coding, and usaully creates more pain than fun when coding.


## Atheltic Software Engineering ~= LeetCoding Culture

In academia, I've been encultured by an interesting niche activity that most software engineers that have confront in their progressional lives, which in this context, our instructors call these *Athletic Software Engineering*. I've written variosu blogs about such culture, including its flaws when hiring a competent software engineer for any type of tech jobs, and as well as my experiences when navigating an internship position in Big Tech. The key premises is that, given a small finite amount of time, generally, fifteen to thirty minutes, you are confronted with an algorithm problem, to such you must provide a solution, generally expected an optimal, optimized implementation of your solution written in your favorite language. Do these enough times succesfully in a tech interview, you're hired. Fail to solve the problem, you're out of the equation.

Apart of this *Athletic Software Engineering*, is the key routine of W.O.Ds. (Workout of The Day), which are short bursts of algorithm questions that we solve in a timely manner. I find any nature of such activities to be a good practice supplement to landing a job in Big Tech. Hence, this style of learning attempts to simulate such process is good exposure to handle a variety of feelings you've often face in the real event. Due to the fact that we are faced wiht hard algorithm problems, high expectations, and short finite amount of time of completition, such activity is inherently stressful. Sometimes I wonder if this core activity correlates to being a competent software engineer, but all i do know, is that we are thrusted in this process that could determine whether we are broke or finacially stable. I think most software engineers generally do not like this type of activity, but is a requirement for breaking entry to a new tech job, that all techies must do, from new grad role to senior engineer. I suppose a good way of thinking about this is that it's the bitter pill we must swallow to be successful, as in, landing an offer, in any technical industries that follow the leetcoding culture.

I used to be a competitive programmer in my freshmen year of University, so I do find such nature of activities enjoyable if and only if there is no high expectations of making it run successfuly. We do it for fun. Algorithms, in general, is still a very interesting field to me, and it's akin to how mathematicians are obsess in solving toy problems is their field of work, or say a physicist modeling and solving toy problems in their free time. Of course, abstracting all the hardware and fancy software frameworks, it all boils down to algorithms and data structures.
